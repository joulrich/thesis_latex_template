\documentclass[thesis.tex]{subfiles}

\begin{document}

\chapter{Realisierung}\label{chap:realisierung}

Nach der Planungs- und Designphase wird nun die Realisierung des Projekts behandelt. Im Detail, die Realisierung des Prototyps, der eine einfache Verbindung zwischen Client und Server ermöglicht sowie die Stabilität sicherstellt.

\section{Technologien und technische Grundlagen}\label{chap:technologien}

Das neue Lone-Worker Feature der Body-Cam erfordert eine dauerhafte, bidirektionale Verbindung zwischen Body-Cam als Client und Überwachungszentrum als Server.
Die Kommunikation soll dabei in Echtzeit ablaufen.
Für diese Anforderungen reichen einfache HTTP-Anfragen nicht aus.
Da diese keine dauerhafte und bidirektionale Kommunikation ermöglichen können.
Um dieses Problem zu beheben wurde das Websocket-Protokoll entwickelt.
Im Gegensatz zu traditionellen HTTP-Anfragen, die eine neue Verbindung zum Server für jede Anfrage öffnen und schließen, ermöglichen WebSockets eine dauerhafte Verbindung.
Diese ermöglicht es Daten in Echtzeit zu senden und zu empfangen.
Darüber hinaus unterstützen WebSockets auch bidirektionale Kommunikation.
Das bedeutet, dass sowohl der Client als auch der Server Daten senden und empfangen können.
Dies ist ideal für Anwendungen wie Multiplayer-Spiele, Chat-Anwendungen oder Echtzeit-Kommunikation, bei denen schnelle und zuverlässige Kommunikation zwischen dem Client und dem Server von entscheidender Bedeutung ist.
Ein weiterer Vorteil von WebSockets ist, dass sie von vielen modernen Browsern und Webanwendungen nativ unterstützt werden.
Dadurch wird die Implementierung der Client-Seite erleichtert, welche sich nicht um die Verwaltung von Verbindungs- oder Datenübertragungsdetails kümmern muss. \cite[vgl. S.4f]{WebsocketProtokoll}

Für die Sicherheit des Lone-Worker ist eine stabile und dauerhafte Verbindung zum Überwachungszentrum von großer Bedeutung.
Es muss ein Verbindungsabbruch schnell festgestellt werden sowie eine Vielzahl von Anfragen bearbeitet werden, um aktuelle Informationen jederzeit bereitzustellen.
Ein Überwachungszentrum ist potenziell mit mehreren Clients verbunden, sodass hier eine effiziente Ressourcennutzung wichtig ist.
Um diesen Anforderungen gerecht zu werden, wurde als Grundgerüst der Kommunikation das Websocket-Protokoll gewählt.

Bei der Kommunikation zwischen Client und Server kann man zwischen zwei Arten unterscheiden.
Der synchronen und der asynchronen Kommunikation.
Synchron bedeutet, dass der Sender auf eine Antwort des Empfängers wartet, bevor er weitere Daten sendet.
Mit anderen Worten, der Sender blockiert den Prozess, bis der Empfänger bestätigt hat, dass er die Daten empfangen hat und bereit ist, weitere Daten zu akzeptieren.
Im Gegensatz dazu bedeutet asynchron, dass der Sender die Daten ohne Bestätigung sendet und der Empfänger die Daten empfängt, wenn sie verfügbar sind, ohne auf eine explizite Bestätigung des Senders zu warten.
Das heißt, der Empfänger blockiert nicht den Prozess und akzeptiert Daten, sobald sie eintreffen.
% reicht ZItat unten oder an jeden Absatz

Synchron und asynchron sind zwei grundlegende Arten der Kommunikation in der Netzwerkprogrammierung.
Synchron bedeutet, dass die Kommunikation zwischen Client und Server blockierend ist, das heißt, der Client wartet auf eine Antwort vom Server, bevor er mit der Ausführung seines Codes fortfahren kann.
Asynchron bedeutet hingegen, dass die Kommunikation nicht blockierend ist, das heißt, der Client kann seine Arbeit fortsetzen, während er auf eine Antwort vom Server wartet.

In einer synchronen Kommunikation sendet der Client eine Anfrage an den Server und wartet, bis der Server eine Antwort zurücksendet.
Der Client blockiert in dieser Zeit und kann nicht auf andere Anfragen oder Ereignisse reagieren.
Wenn der Server lange braucht, um auf die Anfrage zu antworten oder eine Fehlermeldung zurückgibt, blockiert der Client weiterhin.
In einer asynchronen Kommunikation sendet der Client eine Anfrage an den Server und setzt seine Arbeit fort, während er auf die Antwort wartet.
Der Client kann mehrere Anfragen gleichzeitig senden und auf die Antworten warten, wenn sie verfügbar sind.
Bei längeren Antwortzeiten oder einer Fehlermeldung kann der Client weiterhin arbeiten und auf andere Ereignisse reagieren
\cite[vgl. S.1-3]{lim2019directly}.

Aufgrund der begrenzten Ressourcen der Body-Cam als Embedded-Gerät sowie der Möglichkeit, das sich mehrere Clients mit dem Überwachungszentrum verbinden können, wird die asynchrone Kommunikation verwendet.
Diese bietet mehrere Vorteile, wie Skalierbarkeit, Effizienz, Robustheit und Flexibilität.
So kann der Server mit einem Thread mehrere Clients bedienen ohne das die Leistung beeinträchtigt wird, da für jede Anfrage kein separater Thread oder Prozess benötigt wird.
Der Client muss nicht auf die Antwort des Servers warten um mit der nächsten Aufgabe fortzufahren.
Damit kann er mehrere Anfragen gleichzeitig versenden und auf die Antworten reagieren, wenn diese verfügbar sind.
Das steigert die Effizienz auf beiden Seiten der Verbindung.
Im Fehlerfall kann der Client weiterarbeiten und wird nicht durch einen Serverfehler blockiert.
Außerdem ist es damit auch Möglichkeit das Daten gesendet werden können, ohne eine direkte Antwort zu erwarten.
Das ist beispielsweise von Vorteil bei der Implementierung eines Heartbeat zwischen Client und Server
\cite[vgl.]{whyAsync,thinkAsync}.

Für eine dauerhafte und zuverlässige Verbindung zwischen Body-Cam und Überwachungszentrum wird ein Mechanismus benötigt, der einen Verbindungsabbruch in kurzer Zeit feststellt.
Diese Möglichkeit wird von Mobilfunk oder WLAN nativ nicht zur Verfügung gestellt.
Aus diesem Grund wurde für die Kommunikation im Prototypen ein Heartbeat-Mechanismus implementiert.

Heartbeats sind spezielle Signale, die in der Regel zwischen Client- und Server-Anwendungen ausgetauscht werden.
Sie stellen sicher, dass die Verbindung zwischen den beiden Parteien aktiv und stabil bleibt.
Diese Signale können beispielsweise als "Herzschlag" der Verbindung betrachtet werden.
Damit wird gezeigt das die Verbindung immer noch lebt und das die beteiligten Parteien bereit sind Daten auszutauschen.
In der Regel werden Heartbeats in bestimmten Zeitintervallen gesendet, um sicherzustellen, dass die Verbindung nicht ausfällt oder unterbrochen wird.
Wenn ein Client beispielsweise über längere Zeit keine Daten an den Server sendet, könnte der Server fälschlicherweise annehmen, dass die Verbindung unterbrochen wurde, und die Verbindung trennen.
Durch das regelmäßige Senden von Heartbeats kann dies verhindert werden.
Ebenfalls kann dadurch bei Netzwerkproblemen schnell festgestellt werden das die Verbindung zwischen beiden Parteien gestört ist.
Sie tragen damit dazu bei, dass die Verbindung bei Bedarf automatisch wiederhergestellt wird und die Zuverlässigkeit erhöht wird.
Für das Lone-Worker Feature sind sie also wichtig, um dauerhaft eine Verbindung zwischen Client und Server aufrechtzuerhalten und ermöglichen dadurch eine effiziente und zuverlässige Kommunikation zwischen den beiden Parteien.
\textcolor{red}{QUELLE suchen}.

\section{Entwicklungsprozess}

Für die Umsetzung und Implementierung den Prototypen wurde ein agiler Entwicklungsprozess genutzt.
Dafür wurden kontinuierliche Iterationen über alle Phasen des Projekts verwendet.
Als Erstes wurde überlegt, wie die bestehende Body-Cam an die Aufgabe der Überwachung bei Alleinarbeit angepasst werden kann.
Diese Anpassungen wurden als Anforderungen aufgeschrieben und in mehreren Iterationen weiter ausgeführt und verbessert.
Anschließend wurden konkrete Funktionen herausgearbeitet, die durch den neuen Lone-Worker-Modus abgedeckt werden sollen.
Es wurden verschiedene Statemachines entwickelt, die einen ersten Programmablauf beschreiben.
Dieser ging über Verbindungsaufbau, -abbau und -wiederherstellung, den Umgang mit ein- und ausgeheden Nachrichten sowie der Einbindung in die bereits bestehende Body-Cam Implementierung.
Danach wurde das Protokoll für die Kommunikation zwischen Gerät und Überwachungszentrum sowie die Primitiven zwischen Body-Cam und Lone-Worker-Modus herausgearbeitet.
Nach der Designphase begann die Implementierung.
Hier wurde sich als Erstes anhand der Anforderungen und gegebenen Technologien der bestehenden Implementierung für die Technologien aus Kapitel \autoref{chap:technologien} entschieden.
Außerdem wurde im Rahmen der Arbeit die Implementierung des Lone-Worker-Modus auf die Grundfunktionalität des Verbindungsaufbaus, -abbaus und -wiederherstellung begrenzt.
Einzelheiten zur konkreten Umsetzung folgen im nächsten Kapitel.

Zur Entwicklung des Prototyps kam die Programmiersprache C++ sowie ein Linux Ubuntu 20.04 LTS zum Einsatz.
Auf diesem wurden dann alle nötigen Bibliotheken gebaut und mithilfe von CMake eine Projektstruktur entworfen.
Die wichtigsten Bibliotheken sind die Boost-Sammlung, insbesondere Boost-Beast und Boost-Asio für die WebSockets-Verbindung sowie die \glqq rapidjson\grqq{} Bibliothek als JSON-Parser.
CMake kümmert sich außerdem im Prozess des Compiling und Linking um die Verwaltung und Übersetzung der verschiedenen Quelldateien
sowie die Einbindung und Verknüpfung der Header und Bibliotheken.
Dabei wurde der Compiler G++ in der Version 9.4.0 genutzt.
Als Programmiereditor wurde Visual Studio Code mit der Erweiterung \glqq clangd\grqq{} verwendet.
Zur Versionsverwaltung wurde Git genutzt, mit einem eigenen Repository auf GitHub.

\section{Implementierung}

Im praktischen Teil der Bachelorarbeit wurde der Prototyp einer Client-Server-Verbindung implementiert.
Das Hauptaugenmerk lag dabei auf der Umsetzung der Client-Seite.
Konkret wurde eine Kommunikationsbibliothek programmiert, die später in den Code der vorhanden Body-Cam eingebunden werden kann.
Sie erweitert die bestehende Implementierung um das Lone-Worker Feature.
Über die in \autoref{chap:primitiven} beschriebenen Schnittstellen kann die Body-Cam den neuen Lone-Worker-Modus ansteuern.

Die Body-Cam fungiert als Client.
Sobald der Träger die Kamera einschaltet versucht sie sich mit dem Überwachungszentrum zu verbinden, welches vorher konfiguriert werden muss.
Die Aufgaben des Clients beinhalten:
\begin{itemize}
    \item Initialisierung der Lone-Worker-Verbindung zum Überwachungszentrum
    \item Halten einer dauerhaften und stabilen Verbindung zum Server
    \item Wiederherstellung der Kommunikation nach Verbindungsverlust
    \item Schnelle Beantwortung aller Anfragen vom Server
\end{itemize}

Das Überwachungszentrum repräsentiert die Server-Seite.
Sie wartet auf eingehende Verbindungen von Body-Cams und schickt nach dem Verbindungsaufbau in regelmäßigen Abständen Anfragen oder Heartbeats an den Client.
Im Fall das die beiden Seiten nach einer konfigurierbaren Zeitspanne keine neuen Nachrichten von der Gegenseite feststellen, wird eine Fehlermeldung ausgegeben.
Diese Meldung ist der spätere Alarm, den die beiden Seiten bei einem Verbindungsausfall bekommen.

Der Verbindungsaufbau erfolgt über das Websocket-Protokoll.
Die Websocket-Verbindung wird über ein Handshaking-Verfahren aufgebaut.
Dafür werden die asynchronen Methoden aus der Boost-Beast-Bibliothek verwendet.
Als Erstes wird mit einem \glqq async\underline{ }resolve\grqq{} sowie der URL und dem Port die IP-Adresse des Servers ermittelt.
Danach wird mit einem \glqq async\underline{ }connect\grqq{} die Verbindung aufgebaut und über die Methode \glqq async\underline{ }handshake\grqq{} das Handshake-Verfahren durchgeführt.
Nach dieser Prozedur können Server und Client über asynchrone Lese- und Schreibmethoden Nachrichten austauschen.
Im Fehlerfall, wenn beispielsweise der Server nicht erreichbar ist oder das Handshaking-Verfahren fehlschlägt wird die Verbindung beendet.
Das Verbindungsobjekt wird verworfen und nach einer kurzen Verzögerung wird ein erneuter Verbindungsversuch gestartet.
Es kommt zum Alarmfall, wenn keine vollständige Verbindung in einer vorher festgelegten Zeit hergestellt werden kann.

Nachdem eine vollständige Verbindung zwischen Client und Server hergestellt ist, werden vom Server regelmäßig Telegramme an den Client versendet.
Diese Nachrichten sind entweder Anfragen auf beispielsweise Statusinformationen, Standortdaten und Streams oder Heartbeats.
Beim Empfangen einer Nachricht auf Client-Seite wird der Timer, der einen Verbindungsverlust feststellt zurückgesetzt.
Anschließend beantwortet der Client das Telegram.
Der Server-Timer wird ebenfalls neu gestartet, wenn der Server die Antwort registriert.
Mit diesem Vorgehen soll sichergestellt werden, dass ein Verbindungsverlust rechtzeitig erkannt wird und eine schnelle Wiederherstellung der Verbindung vorgenommen werden kann.
Im Fall eines detektierten Verlustes wird nach dem gleichen Prinzip vorgegangen wie bei einem Fehlerfall im Verbindungsaufbau.
Das gewährleistet einen sauberen Wiederaufbau ohne mögliche Artefakte aus älteren Verbindungen.

%Nachrichten klasse zeigen
Die komplette Kommunikation zwischen dem Lone-Worker-Feature der Body-Cam und dem Überwachungszentrum findet über das in \autoref{chap:protokolldesign} beschriebene Protokoll statt.
Dabei wird auf beiden Seiten jede Nachricht mit einer eindeutigen Nummer versehen.
Diese ermöglicht es die Nachrichten zu verfolgen und gezielte Antworten auf Anfragen zu erzeugen.
Durch den einfachen strukturierten Aufbau des Protokolls im JSON-Format, kann es sowohl für die wenigen Funktionen des Prototyps verwendet werden, als auch für alle späteren Funktionen des Lone-Worker-Modus sehr leicht angepasst werden.
Die oben gezeigte Nachrichtenklasse lässt sich mit wenig Arbeit so erweitern, dass verschiedene Statusinformationen oder Anfragen zur Bereitstellung der Streams problemlos vom Client bereitgestellt werden können.

% Weitere wichtige Codestellen zum beschreiben finden?

Aufgrund der begrenzten Ressourcen, die ein Embedded-Gerät wie die Body-Cam zur Verfügung hat sowie die Anforderung an das Überwachungszentrum mehrere Clients gleichzeitig zu verwalten, müssen Performance und Skalierbarkeit berücksichtigt werden.
Aus diesem Grund wurden bereits während der Designphase Entscheidungen getroffen, die in den Prototypen einfließen.
Darunter fallen:
\begin{itemize}
    \item Verwendung von C++ als performante und effiziente Sprache
    \item Einsatz von wenigen und schnellen Bibliotheken wie \glqq rapidjson\grqq{}
    \item Gebrauch des WebSocket-Protokolles
    \item Nutzung der asynchronen gegenüber der synchronen Kommunikation
\end{itemize}

Diese Maßnahmen verbessern die Performance und Skalierbarkeit von Client und Server führen jedoch zu einem höheren Programmieraufwand.
Speziell der Einsatz des asynchronen Konzepts erforderte ein hohes Maß an Einarbeitungszeit sowie eine gesteigerte Fehlerquote.
Durch die Komplexität des nicht-linearen Programmablaufs gestaltet sich das Debugging als anspruchsvolle Aufgabe, welches aufwendigere Maßnahmen zur Fehlerbehebung erforderlich machte.
% hier vllt. ein Vermerk auf einen Text im Anhang machen der genauere Probleme zeigte ehemalige Herausforderungen

\section{Testprotokoll}

Im Kontext der vorliegenden Arbeit sowie der Anforderungen, die an ein PNA durch die DGUV gestellt werden, hat sich herausgestellt das die Stabilität und Zuverlässigkeit einen wesentlichen Bestandteil bilden.
Der Verbindungsaufbau und -abbau sowie die saubere Wiederherstellung der Verbindung im Fehlerfall repräsentieren das Kernstück des Lone-Worker-Modus.
Der im praktischen Teil der Arbeit entwickelte Prototyp implementiert diese Kernelemente.
Aus diesem Grund soll durch ein Testprotokoll sichergestellt werden, dass der Anspruch an eine PNA für Alleinarbeit erfüllt wird.

Im \autoref{anhang:testprotokoll} befindet sich die Ausarbeitung eines für den Prototyp entwickeltes Testprotokoll.
Es beschreibt verschiedene Testfälle mit den erforderlichen Voraussetzungen und Schritten sowie dem erwartenden Ergebnis.
Die Testfälle beziehen sich auf die Kernelemente des Prototyps und umfassen den Verbindungsaufbau zwischen Client und Server,
den Austausch von Heartbeats über das JSON-Protokoll sowie die Verbindungswiederherstellung.
Bei letzterem Testfall gibt es eine Unterscheidung zwischen erfolgreicher und fehlerhafter Wiederherstellung.
Im erfolgreichen Fall kann die Verbindung nach kurzer Zeit reaktiviert werden und die dauerhafte Überwachung ist weiterhin gewährleistet.
Beim Eintritt eines Alarmfalls konnte keine Verbindung zwischen Body-Cam und Überwachungszentrum in der definierten Zeit hergestellt werden.
Die Wiederherstellung ist fehlgeschlagen und beide Seiten haben dies detektiert und teilen dies im Prototyp durch die Programmausgabe mit.
Im späteren Szenarios wird diese Detektion an den Lone-Worker und den Operator weitergeleitet, damit diese über die unterbrochene Überwachung informiert sind.

Jeder Testfall wurde mit dem implementierten Prototyp vollzogen und die Ergebnisse unter jedem Testfall notiert.

\section{Ergebnisse}

Nach dem Planen und Designen des neuen Lone-Worker Feature für die Body-Cam, ist ein weiterer wichtiger Teil die Umsetzung eines Prototyps.
Dieser umfasst die Kommunikationsbasis des Lone-Worker-Modus und verfügt über Verbindungsaufbau, -abbau, -wiederaufbau und Abbrucherkennung.
Der Prototyp wurde im Rahmen des praktischen Teils dieser Arbeit implementiert und mit dem im vorherigen Kapitel entwickelten Testprotokoll, auf Stabilität und Funktionalität überprüft.

Die vier Testfälle wurden vom Prototyp erfolgreich absolviert.
Er ist somit in der Lage eine Verbindung zwischen Body-Cam als Client und Überwachungszentrum als Server aufzubauen, zu halten und wiederherzustellen.
Durch das Nachrichtenprotokoll können Informationen zwischen beiden Seiten ausgetauscht werden.
Im jetzigen Zustand wird dies in erster Linie genutzt, um Heartbeat-Nachrichten zwischen Server und Client auszuwechseln.
Infolgedessen kann der Client den Verlust einer Verbindung in kurzer Zeit erkennen und Maßnahmen zur Wiederherstellung einleiten.
Der Prototyp wurde so designt, dass er als Grundlage dient und mit weiteren, in dieser Arbeit beschriebenen Funktionen, erweitert werden kann.

Gegenwärtig kann das Programm nur über die einzelnen Zustände informieren.
Es gibt zum Beispiel Benachrichtigungen über den Aufbau und Verlust einer Verbindung.
Dem Prototyp ist es jedoch nicht möglich aktiv einen Alarm auf der Body-Cam auszulösen.
Ebenfalls sind Schnittstellen zwischen der aktuellen Body-Cam und dem neuen Lone-Worker-Modus, zum Teil vorbereitet aber noch nicht verfügbar.

Insgesamt wird durch den Prototyp eine solide Kommunikationsbasis geschafften, die in die bestehende Implementierung der Body-Cam eingebunden werden kann.
Er gibt einen ersten Einblick wie eine stabile Verbindung zwischen Body-Cam und Überwachungszentrum realisiert wird.

\subfilebib % Makes bibliography available when compiling as subfile
\end{document}