\documentclass[thesis.tex]{subfiles}

\begin{document}

\chapter{Realisierung}\label{chap:realisierung}

Nach der Planungs- und Designphase wird nun die Realisierung des Projekts behandelt. Im Detail, die Realisierung des Prototyps, der eine einfache Verbindung zwischen Client und Server ermöglicht sowie die Stabilität sicherstellt.

\section{Vorbereitung}
\subsection{Technologien}\label{chap:technologien}

Das neue Lone-Worker Feature der Body-Cam erfordert eine dauerhafte, bidirektionale Verbindung zwischen Body-Cam als Client und Überwachungszentrum als Server.
Die Kommunikation soll dabei in Echtzeit ablaufen.
Für diese Anforderungen reichen einfache HTTP-Anfragen nicht aus.
Da diese keine dauerhafte und bidirektionale Kommunikation ermöglichen können.
Um dieses Problem zu beheben wurde das Websocket-Protokoll entwickelt.
Im Gegensatz zu traditionellen HTTP-Anfragen, die eine neue Verbindung zum Server für jede Anfrage öffnen und schließen, ermöglichen WebSockets eine dauerhafte Verbindung.
Diese ermöglicht es Daten in Echtzeit zu senden und zu empfangen.
Darüber hinaus unterstützen WebSockets auch bidirektionale Kommunikation.
Das bedeutet, dass sowohl der Client als auch der Server Daten senden und empfangen können.
Dies ist ideal für Anwendungen wie Multiplayer-Spiele, Chat-Anwendungen oder Echtzeit-Kommunikation, bei denen schnelle und zuverlässige Kommunikation zwischen dem Client und dem Server von entscheidender Bedeutung ist.
Ein weiterer Vorteil von WebSockets ist, dass sie von vielen modernen Browsern und Webanwendungen nativ unterstützt werden.
Dadurch wird die Implementierung der Client-Seite erleichtert, da Sie sich nicht um die Verwaltung von Verbindungs- oder Datenübertragungsdetails kümmern müssen. \cite[vgl. S.4f]{WebsocketProtokoll}
\\

Für die Sicherheit des Lone-Worker ist eine stabile und dauerhafte Verbindung zum Überwachungszentrum von großer Bedeutung.
Es muss ein Verbindungsabbruch schnell festgestellt werden sowie eine Vielzahl von Anfragen bearbeitet werden, um aktuelle Informationen jederzeit bereitzustellen.
Ein Überwachungszentrum ist potenziell mit mehreren Clients verbunden, sodass hier eine effiziente Ressourcennutzung wichtig ist.
Um diesen Anforderungen gerecht zu werden, wurde als Grundgerüst der Kommunikation das Websocket-Protokoll gewählt.
\\

Bei der Kommunikation zwischen Client und Server kann man zwischen zwei Arten unterscheiden.
Der synchronen und der asynchronen Kommunikation.
Synchron bedeutet, dass der Sender auf eine Antwort des Empfängers wartet, bevor er weitere Daten sendet.
Mit anderen Worten, der Sender blockiert den Prozess, bis der Empfänger bestätigt hat, dass er die Daten empfangen hat und bereit ist, weitere Daten zu akzeptieren.
Im Gegensatz dazu bedeutet asynchron, dass der Sender die Daten ohne Bestätigung sendet und der Empfänger die Daten empfängt, wenn sie verfügbar sind, ohne auf eine explizite Bestätigung des Senders zu warten.
Das heißt, der Empfänger blockiert nicht den Prozess und akzeptiert Daten, sobald sie eintreffen.
\\

Synchron und asynchron sind zwei grundlegende Arten der Kommunikation in der Netzwerkprogrammierung.
Synchron bedeutet, dass die Kommunikation zwischen Client und Server blockierend ist, das heißt, der Client wartet auf eine Antwort vom Server, bevor er mit der Ausführung seines Codes fortfahren kann.
Asynchron bedeutet hingegen, dass die Kommunikation nicht blockierend ist, das heißt, der Client kann seine Arbeit fortsetzen, während er auf eine Antwort vom Server wartet.
\\

In einer synchronen Kommunikation sendet der Client eine Anfrage an den Server und wartet, bis der Server eine Antwort zurücksendet.
Der Client blockiert in dieser Zeit und kann nicht auf andere Anfragen oder Ereignisse reagieren.
Wenn der Server lange braucht, um auf die Anfrage zu antworten oder eine Fehlermeldung zurückgibt, blockiert der Client weiterhin.
In einer asynchronen Kommunikation sendet der Client eine Anfrage an den Server und setzt seine Arbeit fort, während er auf die Antwort wartet.
Der Client kann mehrere Anfragen gleichzeitig senden und auf die Antworten warten, wenn sie verfügbar sind.
Bei längeren Antwortzeiten oder einer Fehlermeldung kann der Client weiterhin arbeiten und auf andere Ereignisse reagieren.
\cite[vgl. S.1-3]{lim2019directly}
\\

Aufgrund der begrenzten Ressourcen der Body-Cam als Embedded-Gerät sowie der Möglichkeit, das sich mehrere Clients mit dem Überwachungszentrum verbinden können, wird die asynchrone Kommunikation verwendet.
Diese bietet mehrere Vorteile, wie Skalierbarkeit, Effizienz, Robustheit und Flexibilität.
So kann der Server mit einem Thread mehrere Clients bedienen ohne das die Leistung beeinträchtigt wird, da für jede Anfrage kein separater Thread oder Prozess benötigt wird.
Der Client muss nicht auf die Antwort des Servers warten um mit der nächsten Aufgabe fortzufahren.
Damit kann er mehrere Anfragen gleichzeitig versenden und auf die Antworten reagieren, wenn diese verfügbar sind.
Das steigert die Effizienz auf beiden Seiten der Verbindung.
Im Fehlerfall kann der Client weiterarbeiten und wird nicht durch einen Serverfehler blockiert.
Außerdem ist es damit auch Möglichkeit das Daten gesendet werden können, ohne eine direkte Antwort zu erwarten.
Das ist beispielsweise von Vorteil bei der Implementierung eines Heartbeat zwischen Client und Server.
(vgl. \cite[]{whyAsync} und \cite[]{thinkAsync})
\\

% heartbeat
% Sache aus einleitung das das nativ nicht zu verfügung gestellt wird und was das ist
% json?
% warum json als Protokoll für die Nachrichten eingesetzt wird steht aber eventuell schon bei Protokoll?

\subsection{Technische Grundlagen}

% https://www.boost.org/doc/libs/1_46_0/doc/html/boost_asio/overview/core/basics.html
% http://blog.think-async.com/2010/04/timeouts-by-analogy.html

\section{Implementierung}
\subsection{Entwicklungsprozess}

Für die Umsetzung und Implementierung den Prototypen wurde ein agiler Entwicklungsprozess genutzt.
Dafür wurden kontinuierliche Iterationen über alle Phasen des Projekts verwendet.
Als ersteres wurde überlegt wie die bestehende Body-Cam an die Aufgabe der Überwachung bei Alleinarbeit angepasst werden kann.
Diese Anpassungen wurden als Anforderungen aufgeschrieben und in mehreren Iterationen weiter ausgeführt und verbessert.
Anschließend wurden konkrete Funktionen herausgearbeitet, die durch den neuen Lone-Worker-Modus abgedeckt werden sollen.
Es wurden verschiedene Statemachines(Fußnote oder auf deutsch lassen?) entwickelt die einen ersten Programmablauf beschreiben.
Dieser ging über Verbindungsaufbau, -abbau und -wiederherstellung, den Umgang mit Ein- und Ausgeheden Nachrichten sowie der Einbindung in die bereits bestehende Body-Cam Implementierung.
Danach wurden das Protokoll für die Kommunikation zwischen Gerät und Überwachungszentrum sowie die Primitiven zwischen Body-Cam und Lone-Worker-Modus herausgearbeitet.
Nach der Designphase begann die Implementierung.
Hier wurde sich als Erstes anhand der Anforderungen und gebeten Technologien der bestehenden Implementierung für die Technologien aus Kapitel \autoref{chap:technologien} entschieden.
Außerdem wurde im Rahmen der Arbeit die Implementierung des Lone-Worker-Modus auf die Grundfunktionalität des Verbindungsaufbaus, -abbaus und -wiederherstellung begrenzt.
Einzelheiten zur konkreten Umsetzung folgen im nächsten Kapitel.
\\

(Bin mir nicht sicher ob das mit rein muss aber es gehört ja zum Entwicklungsprozess)
Zur Entwicklung des Prototyps kam die Programmiersprache C++ sowie ein Linux Ubuntu 20.04 LTS zum Einsatz.
Auf diesem wurden dann alle nötigen Bibliotheken gebaut und mithilfe von CMake eine Projektstruktur entworfen.
CMake kümmert sich außerdem im Prozess des Compiling und Linking um die Verwaltung und Übersetzung der verschiedenen Quelldateien
sowie die Einbindung und Verknüpfung der Header und Bibliotheken.
Dabei wurde der Compiler G++ in der Version 9.4.0 genutzt.
Als Programmiereditor wurde Visual Studio Code mit der Erweiterung \glqq clangd\grqq{} verwendet.
Zur Versionsverwaltung wurde Git genutzt, mit einem eigenen Repository auf GitHub.

\subsection{Umsetzung}
\subsection{Herausforderungen bei der Implementierung}
\section{Ergebnisse}
\subsection{Testprotokoll}
\subsection{Erfüllung der Anforderungen}

\subfilebib % Makes bibliography available when compiling as subfile
\end{document}